\documentclass[t, notes, xcolor=table]{beamer}

\usepackage{wrapfig}
\usepackage{float}
% For tabs in verbatim
\usepackage{fancyvrb}

% Adjust position of the image
\usepackage[export]{adjustbox}

% set fonts
\usefonttheme{professionalfonts} % using non standard fonts for beamer
\usepackage{txfonts,mathptmx}

% set indend spacing for first and second level indentation
\setlength{\leftmargini}{0.5cm}
\setlength{\leftmarginii}{0.5cm}
\setlength{\leftmarginiii}{0.5cm}

% Set circles for bullets 
\setbeamertemplate{itemize items}[circle]

% colors
\usepackage{xcolor}

% multiple columns
\usepackage{multicol}

% todo lists
\usepackage{pifont}
\usepackage{amssymb}

% increase space between text and frame name
\addtobeamertemplate{frametitle}{}{\vspace{0.5em}}

%Information to be included in the title page:
\title{Coding RTL for Synthesis}
\author{Nikola Petrovic}
\institute{University of Belgrade, School of Electrical Engineering}
\date{2022}



\begin{document}

\frame{\titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Module Objective}
In this module we will code design behaviour for logic synthesis.
\newline

\textbf{Topics:}
\begin{itemize}
\item Modeling combinational logic
\item Modeling sequential logic
\item Modeling latch logic
\item Modeling three-state logic
\item Using synthesis attributes
\end{itemize}
\end{frame}
\note{
\scriptsize{
Our objective is to code design behaviours for logic synthesis.
\newline

To do that, we need to know about:
\begin{itemize}
\item Modeling combinational logic
\item Modeling sequential logic
\item Modeling latch logic
\item Modeling three-state logic
\item Using synthesis attributes
\end{itemize}

}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Modeling Combinational Logic}
Combinational Logic: Output is at all times a combinational function solely of the inputs.
\scriptsize{
\begin{multicols}{2}
\begin{itemize}
\item As a \textbf{net declaration} assignment
\item As a \textbf{continuous} assignment
\item As an \textbf{always} statement
\end{itemize}
\vfill
\columnbreak
\begin{figure}
    \includegraphics[width=0.45\textwidth]{img/13_seq_1.png}
\end{figure}
\end{multicols}
\begin{itemize}
\item The event list must not contain a posedge or negedge event.
\begin{itemize}
	\scriptsize{
	\item[$-$] Include all procedure inputs to avoid mismatch between pre-synthesis and post-synthesis designs.	
	}
\end{itemize}
\item Assignments must be blocking, they are sufficient and simulate more efficiently.
\end{itemize}
}
\begin{figure}
    \includegraphics[width=0.75\textwidth]{img/13_seq_2.png}
\end{figure}
\end{frame}
\note{
\tiny{
We can model combinational logic with a net declaration assignment or a continuous assignment or an \textit{always} statements.
\newline

When using an \textit{always} statement, the single event list must not contain a \textit{posedge} or \textit{negedge} event. The event list does not otherwise affect the synthesis results, but to avoid incorrect RTL simulation results, we should include in the event list all inputs to the procedure. The easiest way to ensure this is to use the Verilog 2001 wild-card event control (@*).
\newline

We must not in an \textit{always} statement assign a variable using both a blocking and a non-blocking assignment The blocking assignment is sufficient for a description of combinational logic and simulates more efficiently than the non-blocking assignment.
\newline

\textbf{From IEEE Std. 1364.1-2002} \textit{Section 5.1}:

Combinational logic shall be modeled using a continuous assignment or a net declaration assignment or an
always statement.
\newline

When using an always statement, the event list shall not contain an edge event (posedge or negedge). The
event list does not affect the synthesized netlist. However, it may be necessary to include in the event list all
the variables read in the always statement to avoid mismatches between simulation and synthesized logic.
\newline

A variable assigned in an always statement shall not be assigned using both a blocking assignment (=) and a
nonblocking assignment (\textless=) in the same always statement.
\newline

The event list for a combinational logic model shall not contain the reserved words posedge or negedge. Not
all variables that appear in the right hand side of an assignment are required to appear in the event list. For
example, a variable does not have to appear in the event list of an always statement if it is assigned a value
with a blocking assignment before being used in subsequent expressions within the same always statement.
\newline

The event list may be the implicit event expression list (@(*), @*). 

}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Incomplete Event List}
\scriptsize{
\begin{itemize}
\item For simulation, include in the event list all signals that are input to the logic.
\item The "*" wild-card sensitivity list automatically includes all input signals to the logic.
\end{itemize}
}
\begin{figure}
    \includegraphics[width=0.65\textwidth]{img/13_event.png}
\end{figure}
\end{frame}
\note{
\scriptsize{
The event list does not affect the synthesis result, but to avoid incorrect RTL simulation results, we should include in the event list all inputs to the procedure. The easiest way to ensure this is to use the Verilog 2001 wildcard event control \textbf{(@*)}.
\newline

This example illustrates the affect of an incomplete sensitivity list.
\begin{itemize}
\item If the event list omits the \textit{sel} signal, the procedure executes upon transitions of only the \textit{a} and \textit{b} inputs - transitions of the \textit{sel} signal have no effect.
\item Debugging problems caused by an incomplete sensitivity list is difficult, so we might want to develop the habit of simply always using the wildcard event control for all combinational procedures.
\end{itemize}

\textbf{From IEEE Std. 1364.1-2002} \textit{Section 5.1}:

"The event list does not affect the synthesized netlist."

}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Complete Event List}
\scriptsize{
\begin{multicols}{2}
The event list for a combinational procedure should contain all inputs to the logic.
\begin{figure}
    \includegraphics[width=0.35\textwidth,left]{img/13_complete_event_1.png}
\end{figure}
\vfill
\columnbreak
Do not include temporary variables in the sensitivity list.
\begin{figure}
    \includegraphics[width=0.35\textwidth,left]{img/13_complete_event_2.png}
\end{figure}
\end{multicols}
}
\end{frame}
\note{
\tiny{
The Verilog language let us place any signals in the sensitivity list and to freely mix blocking and non-blocking assignments anywhere in the procedure. A simulation tool simply executes the procedure as we wrote it, using simulation semantics.
\newline

However, to generate RTL simulation results consistent with those of the post-synthesis netlist, some guidelines exist:
\begin{itemize}
\item All edges of all signals input to combinational logic must be present in the sensitivity list. This is due to the rule that any changes on any input to the logic must have the opportunity to immediately affect the output. \textbf{Do not place temporary variables in the sensitivity list!} A temporary variable is one that the procedure writes only before it reads and that no other procedure uses. It is not an input to the logic.
\item Do not mix blocking and non-blocking assignments to the same variable. Even better, we should use only blocking assignments within procedures that represent purely combinational logic. This is a recommendation to obtain higher simulation performance, as non-blocking assignments are not necessary and simulate more slowly.
\end{itemize}
The synthesis tool requires code that unambiguously states our design intentions. Code meant for the synthesis tool may use only a subset of the Verilog constructs and coding styles.
\begin{itemize}
\item For synthesis, it is an absolute requirement that we don't mix blocking and non-blocking assignments to the same variable!
\item The synthesis standard states that the sensitivity list shall not affect the generation of combinational logic. That means that if the synthesis tool recognizes the block as combinational logic, it will proceed as if we had included all inputs to the logic in the sensitivity list. The synthesis tool may or may not warn us about missing inputs. The generated gates will simulate correctly, but very likely differently that the incorrect RTL simulation.
\end{itemize}

}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Incomplete Assignments}
\textbf{Combinational Logic}
\footnotesize{
\begin{itemize}
\item Output is at all times a combinational function solely of the inputs.
\end{itemize}
}
\begin{figure}
    \includegraphics[width=0.95\textwidth]{img/13_incomplete_assign.png}
\end{figure}
\vfill

* What is the value of y when b is 0?
\end{frame}
\note{
\scriptsize{
If an execution path through a combinational procedure exists that does not update the value of some output, then the output variable must retain its previous state. The synthesis tool infers a latch to implement this behaviour. Latch inference is almost always non intended, and we can easily avoid it.
\newline

This example fails to update the \textit{y} output variable when the input \textit{b} is not 1.
\newline

How would you modify this code to ensure inference of purely combinational logic?

}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Complete Assignment}
Avoiding latch inference is easy!
\footnotesize{
\begin{itemize}
\item Provide outputs with a value for every combination of inputs.
\item This is most easily done with default assignments.
\end{itemize}
}
\begin{figure}
    \includegraphics[width=0.75\textwidth]{img/13_complete_assign.png}
\end{figure}
\end{frame}
\note{
\scriptsize{
Here are two methods we can use to prevent latch inference:
\begin{itemize}
\item We can for an \textit{if} statement use an explicit \textit{else} clause and for a \textit{case} statement an explicit default match item.
\item we can provide default values for all procedure outputs at the start of the procedure.
\end{itemize}
Which is the best technique in a real design?
\newline

If we have a procedure with a complex set of conditional assignments, we can easily miss an assignment for one or more of these branches. Making default assignments at the start of the procedure ensures that all procedure outputs have an assignment.
\newline

\textbf{From IEEE Std. 1364.1-2002} \textit{Section 5.5} Support for values x and z:

The value \textbf{x} may be used as a primary on the RHS of an assignment to indicate a don't care value for synthesis.

}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Continuous Assignments}
Continuous assignments drive values onto nets.
\newline

Continuous assignments always represent combinational logic.
\begin{itemize}
\item Impossible to not assign a value for some input combination.
\item Output is always a combinational function of current inputs.
\end{itemize}
\vspace{10pt}
\begin{figure}
    \includegraphics[width=0.45\textwidth]{img/13_cont_assign.png}
\end{figure}
\end{frame}
\note{
\scriptsize{
Continuous assignments and net declaration assignments drive values onto nets. These assignments always represent combinational logic, as it is syntactically impossible to not assign a value for some input combination, thus the output is always a combinational function of the current inputs.

}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Modeling Combinational Logic Summary}
\footnotesize{
Summary of the steps to procedurally describe purely combinational logic:
\begin{itemize}
\item Start the procedure with the \textbf{always} construct.
\item Immediately follow the always construct with an event control.
\begin{itemize}
	\scriptsize{
	\item[$-$] Place all possible input events in the event expression.	
	}
\end{itemize}
\item Group multiple following statements with \textbf{begin...end} block.
\item Provide default assignments to prevent latch inference.
\item Avoid combinational feedback loops.
\item Assign a variable in only one procedure.
\end{itemize}
}
\end{frame}
\note{
\scriptsize{
Here is a summary of the steps to procedurally describe purely combinational logic:
\begin{itemize}
\item Start the procedure with the \textbf{always} construct.
\item Immediately follow the always construct with an event control. Place all possible input events in the event expression.	
\item Group multiple following statements with \textbf{begin...end} block. We can omit the \textbf{begin...end} keywords if we have only a single statement.
\item make blocking assignments. We can equally validly make non-blocking assignments, but they simulate less efficiently and provide no additional benefit. In any case, do NOT mix blocking and non-blocking assignments to the same variable and do NOT make assignments to a variable from multiple procedures.
\item Provide default assignments to prevent latch inference.
\item Avoid combinational feedback loops.
\end{itemize}
Remember that:
\begin{itemize}
\item Continuous assignments always synthesize to combinational logic.
\item Functions almost always synthesize to combinational logic.
\end{itemize}
}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Modeling Sequential Logic}
\textbf{Sequential Logic}
\newline

\footnotesize{
\begin{itemize}
\item Outputs are sampled in registers on a clock edge, thus storage is required.
\item As an always statement:
\begin{itemize}
	\footnotesize{
	\item The event list must contain only posedge and negedge events.
	\item Model set/reset behaviours in an if statement early branches and normal behaviour in the later branches.
	\item Make non-blocking assignments to storage variables.	
	}
\end{itemize}
\end{itemize}
}
\vspace{20pt}
\begin{figure}
    \includegraphics[width=0.75\textwidth]{img/13_seq_logic.png}
\end{figure}

\end{frame}
\note{
\scriptsize{
We model sequential logic using an \textit{always} statement that has one or more \textit{posedge} or \textit{negedge} events in exactly one event list. Exactly one of those events represents the active clock edge that stores the value. Any additional \textit{posedge} or \textit{negedge} events represent asynchronous set and reset behaviours. The event list must NOT contain level-sensitive events.
\newline

We model the asynchronous set and reset behaviours by using an \textit{if} statement in the \textit{if} statement, we model the asynchronous behaviours in one or more conditional branches. The unconditional last \textit{else} branch models the normal sequential behaviour.
\newline

To avoid simulation clock/data races, we should make only non-blocking assignments to variables that represent storage. We make blocking assignments to temporary variables. Temporary variables are those written and then read in the same procedure and nowhere else.

}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Normal Behaviour}
\scriptsize{
\begin{multicols}{2}
The event list for a sequential procedure must contain only single edges of clock signals.
\begin{itemize}
\item All events must be posedge or negedge qualified.
\end{itemize}
The synthesis tool infers registers:
\begin{itemize}
\item For non-temporary variables assigned in sequential procedures:
\begin{itemize}
	\scriptsize{
	\item[$-$] Assigned with non-blocking statements	
	}
\end{itemize}
\end{itemize}
\vfill
\columnbreak
\begin{figure}
    \includegraphics[width=0.45\textwidth]{img/13_seq_normal.png}
\end{figure}
\end{multicols}
}
\end{frame}
\note{
\scriptsize{
Synthesis tools recognize sequential procedures by looking for a particular code template - in this case, a procedure with an event list containing only edge-qualified signals. Although some synthesis tools may support other coding styles for sequential procedures, our adherence to this standard produces code that we can port between all synthesis tools compliant with the standard.
\newline

This example has only the positive edge of the clock in its event list. All storage inferred for non-temporary variables that this procedure writes will have a rising active clock edge. The \textit{if} statement describes the combinational logic calculating the new "count" value that is stored on the nest rising clock edge.
\newline

\textbf{Note that this example lacks a reset to initialize the count value!}

}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Reset Behaviour}
Use an \textbf{if...else} statement to add set/reset to a procedure.
\footnotesize{
\begin{itemize}
\item Put the set/reset behaviour in the first branch.
\item Put the normal sequential behaviour in the last branch.
\item For asynchronous resets, add active set/reset edges to event list.
\end{itemize}
}
\vfill
\begin{figure}
    \includegraphics[width=0.95\textwidth]{img/13_seq_reset.png}
\end{figure}
\end{frame}
\note{
\scriptsize{
We can most easily provide set and reset behaviours by using an \textit{if} statement. This is a requirement for asynchronous set and reset behaviours and strongly recommended for synchronous set and reset behaviours. The synthesis tool will tread synchronous set and reset behaviours we model outside an \textit{if} statement as just that much more combinational logic.
\newline

If the \textit{if} statement, place the set and reset behaviours in their order of priority in the first conditional branches, and place the normal synchronous behaviour in the unconditional last \textit{else} branch. Do NOT make assignments to the storage variable outside of the \textit{if} statement.
\newline
For synchronous set and reset, trigger the procedure on only the clock edge/
\newline

For asynchronous set and reset, trigger the procedure also on the active set and reset edge(s).
\newline
Code synchronously reset, asynchronously reset and non reset registers in separate procedures.

}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Sequential Procedure Templates}
Code must follow these templates:
\footnotesize{
\begin{itemize}
\item Procedure starts with an always construct.
\item Followed by one event control containing only edge-qualified signals.
\begin{itemize}
\footnotesize{
	\item[$-$] Clock
	\item[$-$] Asynchronous set or reset
	}
\end{itemize}
\end{itemize}
}
\vfill
\begin{figure}
    \includegraphics[width=0.95\textwidth]{img/13_seq_template.png}
\end{figure}
\end{frame}
\note{
\scriptsize{
Sequential procedures have the clock edge in the event list, and also the set and reset edge(s) if there is asynchronous set or reset.
\newline

Separately code your non reset, synchronous reset and asynchronous reset procedures.

}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Incomplete Assignments}
\footnotesize{

\textbf{Sequential Logic}
\begin{itemize}
\item Output is not at all times a combinational function solely of the inputs.
\begin{itemize}
	\scriptsize{
	\item[$-$] Implies some kind of storage
	}
\end{itemize}
\item Incomplete assignment in a sequential procedure does not infer a latch.
\begin{itemize}
	\scriptsize{
	\item[$-$] Storage is already there!
	}
\end{itemize}
\end{itemize}

\begin{figure}
    \includegraphics[width=0.3\textwidth]{img/13_seq_incomplete.png}
\end{figure}

}
\end{frame}
\note{
\scriptsize{
If procedure execution does not update a variable, then the variable value is not changed. In procedures representing combinational logic, this infers a latch to store a previous variable value. For procedures representing synchronous logic, the variable value is stored in the inferred register. For these procedures we do not use default assignment or \textit{else} clauses to prevent latch inference.

}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Blocking vs. Non-blocking Assignment}
Write a Verilog sequential procedure to codify this behaviour.
\begin{figure}
    \includegraphics[width=0.95\textwidth]{img/13_block_vs_nonblock.png}
\end{figure}
\end{frame}
\note{
\scriptsize{
Good coding practice demands that we make only non-blocking assignments to variables that represent storage elements. This is to avoid clock/data races in simulation and to avoid unintended logic inference in synthesis. The synthesis standard requires only that we do not mix the two types of assignments to the same variable.
\newline

For examples 1 and 2, we can see that with non-blocking assignments the order of assignments is \textbf{not} important, as simulation schedules the actual assignments for the NBA region of the stratified event queue.
\newline

For examples 3 and 4, we can see that with blocking assignments the order of assignments \textbf{is} important, as the simulation completes the assignments as it executes the statements. Different order generates different simulation results and different synthesis results.
\begin{itemize}
\item Example 3 reads variable \textit{b} before writing it, so synthesis infers two registers.
\item Example 4 reads variable \textit{b} after writing it. Variable \textit{b} is temporary variable. Synthesis infers on register.
\end{itemize}

\textbf{From IEEE Std. 1364.1-2002} \textit{Section 5.2.2} Modeling edge-sensitive storage devices:

Non-blocking procedural assignments should be used for variables that model edge-sensitive storage devices.

}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Temporary Variables in Sequential Procedures}

\scriptsize{
\begin{multicols}{2}
\textbf{Persistent Variable}
\begin{itemize}
\item Read first and then written (in the same procedure)
\item Synthesis must infer a register to hold a value to the next read.
\end{itemize}

\vfill
\columnbreak

\textbf{Temporary Variable}
\begin{itemize}
\item Written first and then read (in the same procedure)
\item Variable is alias for expression so no register is inferred
\end{itemize}

\end{multicols}
}
\begin{figure}
    \includegraphics[width=0.95\textwidth]{img/13_temp_var.png}
\end{figure}
\end{frame}
\note{
\scriptsize{
We can use a temporary variable to hold intermediate result of a calculation before we use the result later in the procedure. We use temporary variables to break complex expressions and combinational logic into a series of smaller steps - making complex logic easier to describe, understand and maintain.
\newline

A temporary variable is one that a procedure writes with a blocking assignment only before the procedure reads it, and no other procedure uses it. We can declare temporary variables locally to ensure that no other procedure uses it.
\newline

A typical use model would be to make blocking assignments to temporary variables and the make non-blocking assignment of the temporary variable values to other variables.
\newline

\textbf{From IEEE Std. 1364.1-2002} \textit{Section 5.2.2} Modeling edge-sensitive storage devices:

Blocking procedural assignments may be used for variables that are temporary assigned and used within an always statement.

}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Modeling Sequential Logic Summary}
\footnotesize{
Summary of the steps to procedurally describe sequential logic:
\begin{itemize}
\item Start the procedure with the \textit{always} construct.
\item Immediately follow the always construct with an event control.
\begin{itemize}
	\scriptsize{
	\item[$-$] Use only posedge or negedge events in the event expression.
	\item[$-$] Include only clock and asynchronous set/reset events.	
	}
\end{itemize}
\item Group multiple following statements within a \textit{begin...end} block.
\item Place the asynchronous set/reset behaviours firs (in their order of priority) in the \textit{if} statement.
Place the normal sequential behaviour in the last \textit{else} branch.
\begin{itemize}
	\scriptsize{
	\item[$-$] Make blocking assignments only to the temporary variables.
	\item[$-$] Make non-blocking assignments to the register variables.	
	}
\end{itemize}
\item Do not make assignments to a variable from multiple procedures.
\end{itemize}
}
\end{frame}
\note{
\scriptsize{
Here is a summary of the steps to procedurally describe sequential logic:
\begin{itemize}
\item Start the procedure with the \textit{always} construct. Immediately follow the always construct with an event control, placing only edge-qualified events in the event expression.
\item Group multiple following statements within a \textit{begin...end} block. We can omit the \textit{begin...end} keywords if we have only a single statement.
\item Make blocking assignments only to the temporary variables and make only non-blocking assignments to variables representing storage. Write the temporary variables only before you read them in the same procedure. Do not make assignments to a variable from multiple procedures.
\end{itemize}

}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Modeling Latch Logic}
But what if we want to infer a latch?
\footnotesize{
\begin{itemize}
\item A combinational block that for some combination of inputs does not provide output value infers storage i.e., a latch.
\item Make assignments for latch logic as we do for sequential logic.
\begin{itemize}
	\scriptsize{
	\item[$-$] Make blocking assignments to only the temporary variables
	\item[$-$] Write temporary variables only before they are read
	\item[$-$] Make non-blocking assignments to the latch variable
	}
\end{itemize}
\end{itemize}
}
\begin{figure}
    \includegraphics[width=0.75\textwidth]{img/13_latch.png}
\end{figure}
\end{frame}
\note{
\scriptsize{
We deliberately infer a latch, if we truly want to, the same way we inadvertently infer a latch, with the exception that we need to remember to make a non-blocking assignment to the variable that represents the latch.
\newline

A latch-based design can have higher performance than a register-based design, but can also be more difficult to correctly design and debug. Use of latches is typically infrequent and reserved for extenuating circumstances.

}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Modeling Three-State Logic}
\begin{figure}
    \includegraphics[width=0.95\textwidth]{img/13_three_state.png}
\end{figure}
\end{frame}
\note{
\scriptsize{
We model three-state logic by assigning the high-impedance value to a net or variable. Any other assignments to that net or variable must also assign the high-impedance value. Further propagating the high-impedance value by use of net or variable assignments does not also make that downstream logic into three-state logic.
\newline

This example codes behaviour representing three-state drivers in a form that synthesis can recognize. For this example:
\begin{itemize}
\item The "enable1" signal when high drives "data\_1" onto the data bus
\item The "enable2" signal when high drives "data\_2" onto the data bus.
\end{itemize}
The synthesis standard does not address what the result should be if multiple enables are simultaneously true.

}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Using Synthesis Attributes}

\end{frame}
\note{
\scriptsize{


}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Module}

\end{frame}
\note{
\scriptsize{


}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Module}

\end{frame}
\note{
\scriptsize{


}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Module}

\end{frame}
\note{
\scriptsize{


}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Module}

\end{frame}
\note{
\scriptsize{


}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Module}

\end{frame}
\note{
\scriptsize{


}
}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Test You Understanding - 1}

\begin{itemize}
\item[$\square$] 
\item[$\square$] 
\item[$\square$] 
\item[$\square$] 
\end{itemize}
\end{frame}
\note{

}



\end{document}
